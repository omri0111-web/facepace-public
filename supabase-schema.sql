-- FacePace Supabase Database Schema
-- Run this in your Supabase SQL Editor

-- ============================================================================
-- TABLES
-- ============================================================================

-- Table: persons
-- Stores information about individuals (scouts, members, etc.)
CREATE TABLE IF NOT EXISTS persons (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  email TEXT,
  age INTEGER,
  age_group TEXT,
  parent_name TEXT,
  parent_phone TEXT,
  allergies TEXT[], -- Array of allergies
  photo_paths TEXT[], -- Array of photo URLs in Supabase Storage
  created_at TIMESTAMP DEFAULT NOW()
);

-- Table: groups
-- Stores group information (patrols, troops, classes, etc.)
CREATE TABLE IF NOT EXISTS groups (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  description TEXT,
  age TEXT,
  guides_info JSONB, -- [{name: "John", phone: "555-1234"}]
  notes TEXT,
  capacity INTEGER DEFAULT 0,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Table: group_members
-- Junction table for many-to-many relationship between groups and persons
CREATE TABLE IF NOT EXISTS group_members (
  group_id UUID REFERENCES groups(id) ON DELETE CASCADE,
  person_id UUID REFERENCES persons(id) ON DELETE CASCADE,
  joined_at TIMESTAMP DEFAULT NOW(),
  PRIMARY KEY (group_id, person_id)
);

-- Table: enrollment_links
-- Stores shareable enrollment links for people to sign themselves up
CREATE TABLE IF NOT EXISTS enrollment_links (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  link_code TEXT UNIQUE NOT NULL, -- Short code like "abc123"
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  group_id UUID REFERENCES groups(id) ON DELETE SET NULL,
  expires_at TIMESTAMP,
  used_count INTEGER DEFAULT 0,
  max_uses INTEGER, -- NULL = unlimited uses
  created_at TIMESTAMP DEFAULT NOW()
);

-- Table: pending_enrollments
-- Stores enrollment submissions awaiting user review/acceptance
CREATE TABLE IF NOT EXISTS pending_enrollments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  enrollment_link_id UUID REFERENCES enrollment_links(id) ON DELETE SET NULL,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE, -- Owner of the link
  name TEXT NOT NULL,
  email TEXT,
  age INTEGER,
  age_group TEXT,
  parent_name TEXT,
  parent_phone TEXT,
  allergies TEXT[],
  photo_urls TEXT[], -- Photos in Supabase Storage: pending/{pending_id}/photo_*.jpg
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'rejected')),
  created_at TIMESTAMP DEFAULT NOW()
);

-- Table: face_embeddings
-- Stores face recognition embeddings generated by Railway backend
CREATE TABLE IF NOT EXISTS face_embeddings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  person_id UUID REFERENCES persons(id) ON DELETE CASCADE,
  embedding FLOAT8[], -- 512-dimensional array from InsightFace
  photo_url TEXT, -- Reference to photo in Supabase Storage
  quality_score FLOAT,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Table: share_requests
-- Stores requests to share people/groups between users
CREATE TABLE IF NOT EXISTS share_requests (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  sender_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  sender_name TEXT,
  sender_email TEXT,
  recipient_email TEXT NOT NULL,
  recipient_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  
  share_type TEXT NOT NULL CHECK (share_type IN ('person', 'group')),
  item_id UUID NOT NULL, -- person_id or group_id
  item_name TEXT,
  item_preview_url TEXT,
  message TEXT,
  
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'declined')),
  expires_at TIMESTAMP DEFAULT (NOW() + INTERVAL '30 days'),
  created_at TIMESTAMP DEFAULT NOW()
);

-- Table: shared_data_snapshots
-- Stores snapshots of data being shared (includes all member data for groups)
CREATE TABLE IF NOT EXISTS shared_data_snapshots (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  share_request_id UUID REFERENCES share_requests(id) ON DELETE CASCADE,
  
  -- Snapshot of person data
  person_data JSONB,
  person_embeddings JSONB,
  
  -- Snapshot of group data (includes all members)
  group_data JSONB,
  group_members_data JSONB, -- Array of {person_data, embeddings}
  
  -- Photo references
  photo_urls TEXT[],
  
  created_at TIMESTAMP DEFAULT NOW()
);

-- ============================================================================
-- INDEXES for better query performance
-- ============================================================================

CREATE INDEX IF NOT EXISTS idx_persons_user_id ON persons(user_id);
CREATE INDEX IF NOT EXISTS idx_groups_user_id ON groups(user_id);
CREATE INDEX IF NOT EXISTS idx_group_members_group_id ON group_members(group_id);
CREATE INDEX IF NOT EXISTS idx_group_members_person_id ON group_members(person_id);
CREATE INDEX IF NOT EXISTS idx_face_embeddings_person_id ON face_embeddings(person_id);
CREATE INDEX IF NOT EXISTS idx_enrollment_links_code ON enrollment_links(link_code);
CREATE INDEX IF NOT EXISTS idx_pending_enrollments_user_id ON pending_enrollments(user_id, status);
CREATE INDEX IF NOT EXISTS idx_share_requests_recipient_email ON share_requests(recipient_email, status);
CREATE INDEX IF NOT EXISTS idx_share_requests_recipient_id ON share_requests(recipient_id, status);

-- ============================================================================
-- ROW LEVEL SECURITY (RLS)
-- This ensures users can only see and modify their own data
-- ============================================================================

-- Enable RLS on all tables
ALTER TABLE persons ENABLE ROW LEVEL SECURITY;
ALTER TABLE groups ENABLE ROW LEVEL SECURITY;
ALTER TABLE group_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE enrollment_links ENABLE ROW LEVEL SECURITY;
ALTER TABLE pending_enrollments ENABLE ROW LEVEL SECURITY;
ALTER TABLE face_embeddings ENABLE ROW LEVEL SECURITY;
ALTER TABLE share_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE shared_data_snapshots ENABLE ROW LEVEL SECURITY;

-- Persons policies: Users can only manage their own people
CREATE POLICY "Users can view own persons"
  ON persons FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own persons"
  ON persons FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own persons"
  ON persons FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own persons"
  ON persons FOR DELETE
  USING (auth.uid() = user_id);

-- Groups policies: Users can only manage their own groups
CREATE POLICY "Users can view own groups"
  ON groups FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own groups"
  ON groups FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own groups"
  ON groups FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own groups"
  ON groups FOR DELETE
  USING (auth.uid() = user_id);

-- Group members policies: Can manage members of their own groups
CREATE POLICY "Users can view own group members"
  ON group_members FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM groups
      WHERE groups.id = group_members.group_id
      AND groups.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can insert own group members"
  ON group_members FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM groups
      WHERE groups.id = group_members.group_id
      AND groups.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can delete own group members"
  ON group_members FOR DELETE
  USING (
    EXISTS (
      SELECT 1 FROM groups
      WHERE groups.id = group_members.group_id
      AND groups.user_id = auth.uid()
    )
  );

-- Enrollment links policies: Users can manage their own links
CREATE POLICY "Users can view own enrollment links"
  ON enrollment_links FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own enrollment links"
  ON enrollment_links FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own enrollment links"
  ON enrollment_links FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own enrollment links"
  ON enrollment_links FOR DELETE
  USING (auth.uid() = user_id);

-- Public can read enrollment links by code (for public enrollment page)
CREATE POLICY "Anyone can read enrollment links by code"
  ON enrollment_links FOR SELECT
  USING (true); -- We'll validate expiry in application logic

-- Pending enrollments policies: Users can manage their own pending enrollments
CREATE POLICY "Users can view own pending enrollments"
  ON pending_enrollments FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can update own pending enrollments"
  ON pending_enrollments FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own pending enrollments"
  ON pending_enrollments FOR DELETE
  USING (auth.uid() = user_id);

-- Public can insert pending enrollments (for public enrollment page)
CREATE POLICY "Anyone can create pending enrollments"
  ON pending_enrollments FOR INSERT
  WITH CHECK (true); -- Link validation happens in application logic

-- Face embeddings policies: Users can only manage embeddings for their own people
CREATE POLICY "Users can view own face embeddings"
  ON face_embeddings FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM persons
      WHERE persons.id = face_embeddings.person_id
      AND persons.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can insert own face embeddings"
  ON face_embeddings FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM persons
      WHERE persons.id = face_embeddings.person_id
      AND persons.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can delete own face embeddings"
  ON face_embeddings FOR DELETE
  USING (
    EXISTS (
      SELECT 1 FROM persons
      WHERE persons.id = face_embeddings.person_id
      AND persons.user_id = auth.uid()
    )
  );

-- Share requests policies: Users can see requests they sent or received
CREATE POLICY "Users can view their share requests"
  ON share_requests FOR SELECT
  USING (
    auth.uid() = sender_id OR 
    auth.uid() = recipient_id OR
    (SELECT email FROM auth.users WHERE id = auth.uid()) = recipient_email
  );

CREATE POLICY "Users can insert share requests"
  ON share_requests FOR INSERT
  WITH CHECK (auth.uid() = sender_id);

CREATE POLICY "Users can update received share requests"
  ON share_requests FOR UPDATE
  USING (
    auth.uid() = recipient_id OR
    (SELECT email FROM auth.users WHERE id = auth.uid()) = recipient_email
  );

-- Shared data snapshots policies: Accessible to sender and recipient
CREATE POLICY "Users can view relevant snapshots"
  ON shared_data_snapshots FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM share_requests
      WHERE share_requests.id = shared_data_snapshots.share_request_id
      AND (
        share_requests.sender_id = auth.uid() OR
        share_requests.recipient_id = auth.uid() OR
        (SELECT email FROM auth.users WHERE id = auth.uid()) = share_requests.recipient_email
      )
    )
  );

CREATE POLICY "Users can insert snapshots for their shares"
  ON shared_data_snapshots FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM share_requests
      WHERE share_requests.id = shared_data_snapshots.share_request_id
      AND share_requests.sender_id = auth.uid()
    )
  );

-- ============================================================================
-- STORAGE BUCKETS
-- Run these in the Supabase Storage section
-- ============================================================================

-- Create a bucket for face photos
-- Go to Storage -> Create a new bucket called 'face-photos'
-- Set it to Private
-- Add these RLS policies for the bucket:

/*
-- Policy 1: Users can upload to their own folder
CREATE POLICY "Users can upload to own folder"
ON storage.objects FOR INSERT
WITH CHECK (
  bucket_id = 'face-photos' AND
  (storage.foldername(name))[1] = auth.uid()::text
);

-- Policy 2: Public can upload to pending folder (for enrollment)
CREATE POLICY "Public can upload to pending folder"
ON storage.objects FOR INSERT
WITH CHECK (
  bucket_id = 'face-photos' AND
  (storage.foldername(name))[1] = 'pending'
);

-- Policy 3: Users can view their own photos
CREATE POLICY "Users can view own photos"
ON storage.objects FOR SELECT
USING (
  bucket_id = 'face-photos' AND
  (storage.foldername(name))[1] = auth.uid()::text
);

-- Policy 4: Users can view pending photos (to review enrollments)
CREATE POLICY "Users can view pending photos"
ON storage.objects FOR SELECT
USING (
  bucket_id = 'face-photos' AND
  (storage.foldername(name))[1] = 'pending'
);

-- Policy 5: Users can delete their own photos
CREATE POLICY "Users can delete own photos"
ON storage.objects FOR DELETE
USING (
  bucket_id = 'face-photos' AND
  (storage.foldername(name))[1] = auth.uid()::text
);

-- Policy 6: Backend service can delete pending photos (after processing)
-- Note: This should use the service_role key in backend, not RLS
CREATE POLICY "Service can delete pending photos"
ON storage.objects FOR DELETE
USING (
  bucket_id = 'face-photos' AND
  (storage.foldername(name))[1] = 'pending'
);
*/


